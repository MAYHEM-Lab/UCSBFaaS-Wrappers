--- client.py	2017-09-02 20:43:27.000000000 -0700
+++ client.py.new	2017-09-02 20:41:28.000000000 -0700
@@ -10,8 +10,7 @@
 # distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 # ANY KIND, either express or implied. See the License for the specific
 # language governing permissions and limitations under the License.
-import logging
-from datetime import datetime, timezone
+import logging,os,boto3,time,uuid,json
 import functools
 
 from botocore import waiter, xform_name
@@ -42,6 +41,16 @@
 
 logger = logging.getLogger(__name__)
 
+def fixup_kwargs(kwargs,arn,reqID,noPayload=False):
+    #add eventSource with the calling function's requestID to be able to link caller and callee
+    if noPayload:
+        js = {}
+    else:
+        js = json.loads(kwargs['Payload'])
+    sarn = arn.split(":")
+    arn = sarn[6]
+    js['eventSource'] = 'lib:invokeCLI:{}:{}'.format(arn,reqID)
+    kwargs['Payload'] = json.dumps(js)
 
 class ClientCreator(object):
     """Creates client objects for a service."""
@@ -71,6 +80,7 @@
             service_model, region_name, is_secure, endpoint_url,
             verify, credentials, scoped_config, client_config, endpoint_bridge)
         service_client = cls(**client_args)
+        self._register_retries(service_client)
         self._register_s3_events(
             service_client, endpoint_bridge, endpoint_url, client_config,
             scoped_config)
@@ -96,11 +106,10 @@
         json_model = self._loader.load_service_model(service_name, 'service-2',
                                                      api_version=api_version)
         service_model = ServiceModel(json_model, service_name=service_name)
-        self._register_retries(service_model)
         return service_model
 
-    def _register_retries(self, service_model):
-        endpoint_prefix = service_model.endpoint_prefix
+    def _register_retries(self, client):
+        endpoint_prefix = client.meta.service_model.endpoint_prefix
 
         # First, we load the entire retry config for all services,
         # then pull out just the information we need.
@@ -110,15 +119,17 @@
 
         retry_config = self._retry_config_translator.build_retry_config(
             endpoint_prefix, original_config.get('retry', {}),
-            original_config.get('definitions', {}))
+            original_config.get('definitions', {}),
+            client.meta.config.retries
+        )
 
         logger.debug("Registering retry handlers for service: %s",
-                     service_model.service_name)
+                     client.meta.service_model.service_name)
         handler = self._retry_handler_factory.create_retry_handler(
             retry_config, endpoint_prefix)
         unique_id = 'retry-config-%s' % endpoint_prefix
-        self._event_emitter.register('needs-retry.%s' % endpoint_prefix,
-                                     handler, unique_id=unique_id)
+        client.meta.events.register('needs-retry.%s' % endpoint_prefix,
+                                    handler, unique_id=unique_id)
 
     def _register_s3_events(self, client, endpoint_bridge, endpoint_url,
                             client_config, scoped_config):
@@ -307,8 +318,63 @@
             if args:
                 raise TypeError(
                     "%s() only accepts keyword arguments." % py_operation_name)
+            #GammaRay
+            # SpotWrap additions to capture AWS API calls
+            reqID = 'unknown'
+            tname = 'spotFns'
+            if 'spotReqID' in os.environ: 
+                reqID = os.environ['spotReqID']
+            if 'gammaTable' in os.environ:
+                tname = os.environ['gammaTable']
+            # Skip it all if its a put to the GammaRay table name 
+            tail = '12345'
+            ts = 0.0
+            if not(reqID == 'unknown' or (operation_name == 'PutItem' and kwargs['TableName'] == tname)):
+                tail = '{}'.format(str(uuid.uuid4())[:8])
+                if DDBTABLE is None:
+                    if 'gammaRegion' in os.environ:
+                        reg = os.environ['gammaRegion']
+                    dynamodb = boto3.resource('dynamodb', region_name=reg)
+                    DDBTABLE = dynamodb.Table(tname)
+                #create the record
+                payload = 'start:{}:{}:'.format(operation_name,self._endpoint)
+                for k in kwargs:
+                    payload += ':{}:{}'.format(k,kwargs[k])
+                #insert this caller's reqID to the callee's payload for tracing
+                if 'Payload' in kwargs:
+                    if 'eventSource' in kwargs['Payload']:
+                        fixup_kwargs(kwargs,myArn,reqID,True)
+                    else:
+                        fixup_kwargs(kwargs,myArn,reqID,False)
+
+                reqID = '{}:{}'.format(os.environ['spotReqID'],tail)
+                ts = time.time() * 1000 #msecs
+                tsint = int(round(ts))
+                DDBTABLE.put_item( Item={
+                    'reqID': reqID,
+                    'ts': tsint,
+                    'gr_payload': payload,
+                    }
+                )
+
+
             # The "self" in this scope is referring to the BaseClient.
-            return self._make_api_call(operation_name, kwargs)
+            retn = self._make_api_call(operation_name, kwargs)
+
+            #GammaRay
+            if not(reqID == 'unknown' or (operation_name == 'PutItem' and kwargs['TableName'] == tname)):
+                reqID = '{}:{}'.format(os.environ['spotReqID'],tail)
+                tsend = time.time() * 1000 #msecs
+                tsint = int(round(tsend))
+                diff = tsend-ts
+                DDBTABLE.put_item( Item={
+                    'reqID': reqID,
+                    'ts': tsint,
+                    'payload': 'SDKend:{}'.format(str(diff)),
+                    }
+                )
+
+            return retn
 
         _api_call.__name__ = str(py_operation_name)
 
@@ -682,9 +748,11 @@
             documented_paginator_cls = type(
                 paginator_class_name, (Paginator,), {'paginate': paginate})
 
+            operation_model = self._service_model.operation_model(actual_operation_name)
             paginator = documented_paginator_cls(
                 getattr(self, operation_name),
-                paginator_config)
+                paginator_config,
+                operation_model)
             return paginator
 
     def can_paginate(self, operation_name):
